System.register([],function(_){"use strict";return{execute:function(){_("atom",I);let G=0;function I(t,r){const i=`atom${++G}`,d={toString:()=>i};return typeof t=="function"?d.read=t:(d.init=t,d.read=L,d.write=N),r&&(d.write=r),d}function L(t){return t(this)}function N(t,r,i){return r(this,typeof i=="function"?i(t(this)):i)}const T=(t,r)=>t.unstable_is?t.unstable_is(r):r===t,V=t=>"init"in t,B=t=>!!t.write,E=()=>[new Set,new Set],A=(t,r)=>{(t[0]||t[1]).add(r)},k=(t,r)=>{let i;if(r){if(t[0])return;i=t[1]}else{if(!t[0])throw new Error("[Bug] cannot sync flush twice");i=t[0]}const d=new Set;for(;i.size;){const f=new Set(i);i.clear(),f.forEach(g=>{if(typeof g=="function")g();else{const[j,S]=g;!d.has(j)&&S.m&&(S.m.l.forEach(b=>b()),d.add(j))}})}return t[0]=void 0,d},M=Symbol(""),F="pending",R="fulfilled",U="rejected",$=t=>typeof t=="object"&&t!==null&&M in t,D=new WeakMap,q=(t,r,i)=>{if(!D.has(t)){let d;const f=new Promise((g,j)=>{let S=t;const b=m=>v=>{S===m&&(f.status=R,f.value=v,g(v),i())},p=m=>v=>{S===m&&(f.status=U,f.reason=v,j(v),i())};t.then(b(t),p(t)),d=(m,v)=>{m&&(D.set(m,f),S=m,m.then(b(m),p(m))),r(),r=v}});f.status=F,f[M]=d,D.set(t,f)}return D.get(t)},x=t=>typeof(t==null?void 0:t.then)=="function",P=t=>{var r;const i=(r=t.s)==null?void 0:r.v;return $(i)&&i.status===F?i:null},W=t=>{if("e"in t.s)throw t.s.e;return t.s.v},z=(t,r,i=()=>{},d=()=>{})=>{const f=P(t);if(x(r))if(f)f!==r&&f[M](r,i);else{const g=q(r,i,d);t.s={v:g}}else f&&f[M](Promise.resolve(r),i),t.s={v:r}},H=_("createStore",()=>{const t=new WeakMap,r=n=>{let s=t.get(n);return s||(s={d:new Map,t:new Set},t.set(n,s)),s},i=n=>{const s=r(n);for(const e of s.d.keys())r(e).t.delete(n);s.d.clear()},d=(n,s,e,u)=>{const l=r(n);if(l.d.set(s,e.s),e.t.add(n),!u&&l.m){const c=E();p(c,l),k(c)}},f=(n,s)=>{const e=r(n);if(!s&&"s"in e&&(e.m||Array.from(e.d).every(([o,w])=>{const y=f(o);return"v"in w&&"v"in y.s&&Object.is(w.v,y.s.v)})))return e;i(n);let u=!0;const l=o=>{if(T(n,o)){const y=r(o);if(!y.s)if(V(o))z(y,o.init);else throw new Error("no atom init");return W(y)}const w=f(o);return d(n,o,w,u),W(w)};let c,a;const h={get signal(){return c||(c=new AbortController),c.signal},get setSelf(){return!a&&B(n)&&(a=(...o)=>{if(!u)return b(n,...o)}),a}};try{const o=n.read(l,h);return z(e,o,()=>c==null?void 0:c.abort(),()=>{if(e.m){const w=E();p(w,e),k(w)}}),e}catch(o){return e.s={e:o},e}finally{u=!1}},g=n=>W(f(n)),j=(n,s)=>{const e=[],u=new Set,l=a=>{if(!u.has(a)){u.add(a);for(const h of r(a).t)a!==h&&l(h);e.push(a)}};l(s);const c=new Set([s]);for(let a=e.length-1;a>=0;--a){const h=e[a],o=r(h),w=o.s;let y=!1;for(const O of o.d.keys())if(O!==h&&c.has(O)){y=!0;break}y&&(o.m||P(o))&&(f(h,!0),p(n,o),(!w||!("v"in w)||!("v"in o.s)||!Object.is(w.v,o.s.v))&&(A(n,[h,o]),c.add(h)))}},S=(n,s,...e)=>{const u=c=>W(f(c)),l=(c,...a)=>{let h;if(T(s,c)){if(!V(c))throw new Error("atom not writable");const o=r(c),w=o.s,y=a[0];z(o,y),p(n,o);const O=o.s;(!w||!("v"in w)||!("v"in O)||!Object.is(w.v,O.v))&&(A(n,[c,o]),j(n,c))}else h=S(n,c,...a);return k(n,!0),h};return s.write(u,l,...e)},b=(n,...s)=>{const e=E(),u=S(e,n,...s);return k(e),u},p=(n,s)=>{if(s.m&&!P(s)){for(const e of s.d.keys())s.m.d.has(e)||(m(n,e),s.m.d.add(e));for(const e of s.m.d||[])s.d.has(e)||(v(n,e),s.m.d.delete(e))}},m=(n,s)=>{const e=r(s);if(!e.m){f(s);for(const u of e.d.keys())m(n,u);if(e.m={l:new Set,d:new Set(e.d.keys())},B(s)&&s.onMount){const u=e.m,{onMount:l}=s;A(n,()=>{const c=l((...a)=>S(n,s,...a));c&&(u.u=c)})}}return e.m},v=(n,s)=>{const e=r(s);if(e.m&&!e.m.l.size&&!Array.from(e.t).some(u=>r(u).m)){const u=e.m.u;u&&A(n,u),delete e.m;for(const c of e.d.keys())v(n,c);const l=P(e);l&&l[M](void 0,()=>{})}};return{get:g,set:b,sub:(n,s)=>{const e=E(),u=m(e,n);k(e);const l=u.l;return l.add(s),()=>{l.delete(s);const c=E();v(c,n),k(c)}}}});let C;const J=_("getDefaultStore",()=>(C||(C=H()),C))}}});
